#lang scribble/manual

@(require [for-label punct/core
                     punct/doc
                     punct/element
                     punct/fetch
                     punct/parse
                     punct/render/base
                     punct/render/html
                     punct/render/plaintext
                     punct/render/typst
                     racket/base
                     racket/class
                     racket/contract/base
                     racket/match
                     (only-in xml xexpr? xexpr->string)])

@(require scribble/examples "tools.rkt")
@(define ev (sandbox))
@(ev '(require punct/doc punct/parse punct/element))

@title{Module Reference}

@section{Core}

@defmodule[punct/core]

@defparam[current-metas metas (or/c hash-eq? #f)]{

A parameter that, during compilation of a Punct source, holds the metadata hash table for that file.
The final value of this parameter becomes the value of @racket[document-metas] for that file's
@racketidfont{doc} as well as its @racketidfont{metas} export.

The only key automatically defined in every metadata table is @racket['here-path], which holds the
absolute path to the source file.

If no Punct file is currently being compiled, this parameter will hold @racket[#f] by default. In
particular, this parameter is @emph{not} automatically set to a Punct file's @racketidfont{metas}
during the rendering phase (e.g., @racket[doc->html]).

}

@defproc[(set-meta [key symbol?] [val (not/c procedure?)]) void?]{

Set the value of @racket[_key] in @racket[current-metas] to @racket[_val]. If there are no current
metas, an ugly exception is thrown.

}

@defform[(? key val-expr ...)]{

Within a Punct file, this macro can be used as shorthand for @racket[set-meta]. Each @racket[_key]
is given as a bare identifier (i.e., without using @racket[quote]).

@codeblock{
#lang punct

•?[title "Example Title" author "Me"]

...}

}

@subsection{Elements}

@declare-exporting[punct/element punct/core]
@defmodule[punct/element #:no-declare]

The bindings provided by this module are also provided by @racketmodname[punct/core].

@defproc[(default-element-function [tag symbol?]
                                   [default-attr-kw keyword?]
                                   [default-attr-val string?] ...)
         (->* () #:rest any/c xexpr?)]{

Returns a function which produces a @racket[_tag] @tech{custom element}. This function takes any
number of keyword arguments (which are converted to attributes) and non-keyword arguments (which
become the child elements of this returned element).

You can also give keyword/value arguments to @racket[default-element-function] itself; these will be
set as default attributes/values in the custom element returned by the resulting function.

@examples[#:eval ev
          (define aside (default-element-function 'aside))
          (aside "Hello")
          (define kbd (default-element-function 'kbd #:alt "foo"))
          (kbd "CTRL")
          (kbd "CTRL" #:data-code "1")
          ]

@margin-note{On Mac OS, type @tt{ALT+6} to produce @litchar{§} and @tt{ALT+7} to produce @litchar{¶}.}

If @racket[tag] ends in either @litchar{§} or @litchar{¶}, the resulting function will add a default
@tech{block attribute} of @racket{root} or @racket{single} respectively:

@examples[#:eval ev
          (define info (default-element-function 'info§))
          (info "Note!")
          (define mypar (default-element-function 'mypar¶))
          (mypar "Walnuts")]

If @racket[tag] has a suffix of the form @racketidfont{.foo}, the resulting function will add a default
@racket['class] attribute whose value is set to @racket{foo}. Multiple such suffixes will add
additional values to the @racket['class] attribute.

@examples[#:eval ev
          (define carton (default-element-function 'carton.xyz.abc))
          (carton "Cashews")
          (define crate (default-element-function 'crate¶.foo))
          (crate "Pecans")]

@history[#:added "1.3"]

}

@defform*[[(define-element id [default-attr-kw default-attr-val ...])
           (define-element id tag [default-attr-kw default-attr-val ...])]
          #:contracts ([default-attr-kw keyword?]
                       [default-attr-val string?])]{

Shorthand macro for @racket[default-element-function].

If @racket[tag] is supplied, it is used as the tag for the X-expressions generated by the resulting
function:

@examples[#:eval ev #:label #f
          (define-element bowl container.bowl)
          (bowl "Corn nuts")
          (define-element jar vessel¶ #:type "Glass")
          (jar "Chestnuts")]

If @racket[tag] is not supplied, the first argument is used both as the identifier for the function
and for the tag in generated X-expressions:

@examples[#:eval ev #:label #f
          (define-element bag.xyz.abc)
          (bag "Sunflower seeds")
          (define-element packet¶.foo)
          (packet "Raisins")]

@history[#:added "1.3"]

}

@section{Fetch}

@defmodule[punct/fetch]

@defproc[(get-doc [src path-string?]) document?]{

Returns the @racketidfont{doc} binding from @racket[_src]. No caching is used; this function is
basically a thin wrapper around @racket[dynamic-require]. If @racket[_src] does not exist, you will
get a friendly error message. If any other kind of problem arises, you will get an ugly error.

}

@defproc[(get-meta [doc document?]
                   [key symbol?]
                   [default failure-result/c (lambda () (raise (make-exn:fail ....)))])
         any/c]{

Returns the value of @racket[_key] in the @racket[document-metas] of @racket[_doc].
The value of @racket[_default] is used if the key does not exist: if it is a value, that value will be
returned instead; if it is a thunk, the thunk will be called.

@history[#:changed "1.1" @elem{Removed @racketidfont{get-doc-ref} and replaced with @racket[get-meta]}]

}

@defproc[(meta-ref [doc document?] [key symbol?]) any/c]{

Equivalent to @racket[(get-meta doc key #f)]. Provided for compatibility.

}


@section{Parse}

@defmodule[punct/parse]

@defproc[(parse-markup-elements [metas hash-eq?]
                                [elements list]
                                [#:extract-inline? extract? #t]
                                [#:parse-footnotes? parse-fn? #f])
         (or/c document? (listof xexpr?))]{

Parses @racket[_elements] into a Punct AST by serializing everything as strings, sending the string
through the @racketmodname[commonmark] parser, and then converting the result into a Punct
@racket[document], reconstituting any @tech{custom elements} in the process.

If @racket[#:extract-inline?] is @racket[#true], and if the parsed document contains only a single
@tt{paragraph} element at the root level, then the elements inside the paragraph are returned as a
list (the paragraph is "shucked"). Otherwise, the entire result is returned as a @racket[document].

The @racket[#:parse-footnotes?] argument determines whether the @racketmodname[commonmark] parser
will parse Markdown-style footnote references and definitions in @racket[_elements].

@examples[#:eval ev

(define elems
  '("# Title\n\nA paragraph with *italic* text, and "
    1
    (custom "custom element")))
(parse-markup-elements (hasheq) elems)]

}

@section[#:tag "rendering-api"]{Rendering}

Punct currently includes renderers for HTML, Typst, and plain-text. These are based on a "base"
renderer class that you can extend to customize the rendering process or to target new output formats.

@subsection[#:tag "rendering-custom-elements"]{Rendering custom elements}

When rendering your document to a specific output format (such as HTML) Punct has to decide how to
render any @tech{custom elements} introduced by your code. When Punct encounters a custom element,
it passes it to a @deftech{fallback function}: the fallback function receives three arguments: the
custom element’s tag, its attributes, and a list of sub-elements found inside the element. The
sub-elements will already have been fully processed by Punct.

A separate @tech{fallback function} is needed for each output format you want to target. Punct
provides default fallback functions the target output format it supports natively. For example, when
targeting HTML, Punct defaults to @racket[default-html-tag], which simply converts custom elements
to HTML elements. If you want more customized behavior, you'll need to provide your own fallback
procedure to the renderer.

Here's an example pair of functions for rendering documents containing the custom @tt{abbreviation}
element (from the examples above) into HTML:

@racketblock[

(define (custom-html tag attrs elems)
  (match (list tag attrs)
    [`(abbreviation [[term ,term]]) `(abbr [[title ,term]] ,@elems)]))

(define (my-html-renderer source-path)
  (doc->html (get-doc source-path) custom-html))

]

@subsection{HTML}

@defmodule[punct/render/html]

@defproc[(doc->html [pdoc document?]
                    [fallback (-> symbol?
                                  (listof (list/c symbol? string?))
                                  (listof xexpr?)
                                  xexpr?) default-html-tag])
         string?]{

Renders @racket[_pdoc] into a string containing HTML markup. Each @tech{custom element} is passed to
@racket[_fallback], which must return an @racketlink[xexpr?]{X-expression}.

This function uses @racket[xexpr->string] to generate the HTML string. This function will blindly
escape characters inside @racketoutput{<script>} and @racketoutput{<style>} tags, which may
introduce errors. For HTML output that is friendlier and more correct, consider using the
@racketmodname[html-printer #:indirect] package in concert with @racket[doc->html-xexpr].

For more information on using the @racket[_fallback] argument to render custom elements, see
@secref["rendering-custom-elements"].

}

@defproc[(doc->html-xexpr [pdoc document?]
                          [fallback (-> symbol?
                                        (listof (list/c symbol? string?))
                                        (listof xexpr?)
                                        xexpr?) default-html-tag])
         xexpr?]{

Renders @racket[_pdoc] into HTML, but in @racketlink[xexpr?]{X-expression} form rather than as a
string. Each @tech{custom element} is passed to @racket[_fallback], which must itself return an
X-expression.

For more information on using the @racket[_fallback] argument to render custom elements, see
@secref["rendering-custom-elements"].

}

@defproc[(default-html-tag [tag symbol?]
                           [attributes (listof (list/c symbol? string?))]
                           [elements (listof xexpr?)])
         xexpr?]{

Returns an X-expression comprised of @racket[_tag], @racket[_attributes] and @racket[_elements].
Mainly used as the default @tech{fallback function} for @racket[doc->html].

@examples[#:eval ev
(require punct/render/html)
(default-html-tag 'kbd '() '("Enter"))
(default-html-tag 'a '((href "http://example.com")) '("Link"))
]
}

@defclass[punct-html-render% punct-abstract-render% ()]{

The HTML renderer class. Extends @racket[punct-abstract-render%] to produce HTML output.
You can extend this class to customize HTML rendering behavior.

See @secref["extending-renderer"] for examples of extending the HTML renderer.

}

@subsection{Typst}

@defmodule[punct/render/typst]

@link["https://typst.app"]{Typst} is a modern typesetting system designed as an alternative to LaTeX.
This renderer produces Typst markup from Punct documents.

@defproc[(doc->typst [pdoc document?]
                     [fallback (symbol? (listof (listof symbol? string?)) list? . -> . string?)
                               default-typst-tag]) string?]{

Renders @racket[_pdoc] into a string containing Typst markup. Any @tech{custom elements} are passed
to @racket[_fallback], which must return a string.

Markdown/Punct elements are mapped to Typst syntax as follows:

@tabular[#:style 'boxed
         #:column-properties '(left left)
         #:row-properties '(bottom-border ())
  (list (list @bold{Punct element} @bold{Typst output})
        (list "Headings" @elem{@elem[#:style 'tt]{@literal{= Heading}} (with levels as @tt{=} count)})
        (list "Bold" @elem[#:style 'tt]{@literal{*text*}})
        (list "Italic" @elem[#:style 'tt]{@literal{_text_}})
        (list "Inline code" @elem[#:style 'tt]{@literal{`code`}})
        (list "Code blocks" @elem[#:style 'tt]{@literal{```lang ... ```}})
        (list "Links" @elem[#:style 'tt]{@literal{#link("url")[text]}})
        (list "Images" @elem[#:style 'tt]{@literal{#image("path")}})
        (list "Bullet lists"@elem[#:style 'tt]{ @literal{- item}})
        (list "Numbered lists" @elem[#:style 'tt]{@literal{+ item}})
        (list "Block quotes"@elem[#:style 'tt]{@literal{#quote(block: true)[...]}})
        (list "Footnotes" @elem{@elem[#:style 'tt]{@literal{#footnote[...]}} (inline)}))]

Typst special characters (@litchar{*}, @litchar{_}, @litchar{`}, @litchar{#},
@litchar["@"], @litchar{$}, @litchar{[}, @litchar{]}) in text content are automatically escaped,
allowing the same Punct source to target both HTML and Typst without manual escaping. Content inside
code blocks and inline code is not escaped, as Typst renders these literally.

For more information on using the @racket[_fallback] argument to render custom elements, see
@secref["rendering-custom-elements"].

@history[#:added "1.4"]

}

@defproc[(default-typst-tag [tag symbol?] [attributes (listof (listof symbol? string?))] [elements list?]) string?]{

Returns a Typst function call string comprised of @racket[_tag] and @racket[_elements].
Mainly used as the default @tech{fallback function} for @racket[doc->typst].

Note that @racket[_elements] are already escaped when passed to the fallback. If your custom fallback
uses @racket[_attributes], you must escape attribute values manually using @racket[escape-typst-text]
or @racket[escape-typst-string].

@history[#:added "1.4"]

}

@defproc[(escape-typst-text [str string?]) string?]{

Escapes special Typst characters (@litchar{*}, @litchar{_}, @litchar{`}, @litchar{#},
@litchar["@"], @litchar{$}, @litchar{[}, @litchar{]}, @litchar{\}) in @racket[_str] by
prefixing them with backslashes. Use this for text content in custom fallback procedures.

@history[#:added "1.4"]

}

@defproc[(escape-typst-string [str string?]) string?]{

Escapes backslashes and double quotes in @racket[_str] for use within quoted Typst strings
(e.g., URLs or file paths in function arguments like @tt{#link("...")} or @tt{#image("...")}).

@history[#:added "1.4"]

}

@defclass[punct-typst-render% punct-abstract-render% ()]{

The Typst renderer class. Extends @racket[punct-abstract-render%] to produce Typst markup output.
You can extend this class to customize Typst rendering behavior.

@history[#:added "1.4"]

}

@subsection{Plain text}

@defmodule[punct/render/plaintext]

Sometimes you want to convert a document into a text format that is even plainer than Markdown, such
as when generating the plaintext version of an email newsletter.

@defproc[(doc->plaintext [pdoc document?]
                         [line-width exact-nonnegative-integer?]
                         [fallback (-> symbol?
                                       (listof (list/c symbol? string?))
                                       (listof xexpr?)
                                       xexpr?)
                                   (make-plaintext-fallback line-width)])
                         string?]{

Renders @racket[_pdoc] into a string of plain text, hard-wrapped to @racket[_line-width] characters
(except for block-quotes, which are hard-wrapped to a length approximately 75% as long as
@racket[_line-width]). Any @tech{custom elements} are passed to @racket[_fallback], which must
return a string.

The function applies very rudimentary text formatting which usually looks as you would expect, but
which often discards information.

@itemlist[

@item{Level 1 headings are underlined with @litchar{=}, and all other headings are underlined with
@litchar{-}.}

@item{Link destination URLs are given inside parentheses directly following the link text.}

@item{Code blocks are indented with four spaces, and the language name, if any, is discarded.}

@item{Images are replaced with their "alt" text, prefixed by @racket["Image: "] and wrapped in
parentheses; the source URL and title are discarded.}

]

For more information on using the @racket[_fallback] argument to render custom elements, see
@secref["rendering-custom-elements"].

@examples[#:eval ev
          (require punct/render/plaintext)
          (define email (parse-markup-elements (hasheq) '("# Issue No. 1\n\nHowdy!")))
          (display (doc->plaintext email 72))]

}

@defproc[(make-plaintext-fallback [width exact-nonnegative-integer?])
         (symbol? (listof (listof symbol? string?)) list? . -> . string?)]{

Returns a function that accepts three arguments (the tag, attributes and elements of an
X-expression).  Mainly used to create the default fallback procedure for @racket[doc->plaintext].

@examples[#:eval ev
(define foo (make-plaintext-fallback 72))
(foo 'kbd '() '("Enter"))
(foo 'a '((href "http://example.com")) '("Link"))
]
}

@subsection{Base renderer}

@defmodule[punct/render/base]

@defclass[punct-abstract-render% object% ()]{

The abstract base class for all Punct renderers. To create a custom renderer, extend this class
and implement all abstract methods. The built-in HTML, Typst, and plaintext renderers all
extend this class.

@defconstructor[([doc document?]
                 [render-fallback (-> symbol?
                                      (listof (list/c symbol? string?))
                                      list?
                                      any/c)])]{
Creates a new renderer instance. The @racket[doc] argument is the Punct document to render.
The @racket[render-fallback] procedure is called for any @tech{custom elements} encountered
during rendering.
}

@defmethod[(render-document) any/c]{
The main entry point for rendering. Calls the appropriate rendering methods for each element
in the document body and footnotes.

The default implementation returns two values: a list of rendered body elements and a list
of rendered footnotes. Subclasses typically override this to combine these into a single
output value (e.g., a string or X-expression).
}

@defmethod[(render-string [s string?]) any/c]{
Called for every string in the document. Override this to transform raw text (e.g., for
escaping special characters in the target format). The default implementation returns
the string unchanged.A

@history[#:added "1.4"]

}

To create a custom renderer, extend this class and implement all of the abstract methods below.

@margin-note{See @secref["extending-renderer"] for examples of extending the base renderer.}

@defmethod[(render-thematic-break) any/c]
@defmethod[(render-heading [level string?] [rendered-elems list?]) any/c]
@defmethod[(render-code-block [info-string string?] [raw-elems list?]) any/c]
@defmethod[(render-html-block [raw-content any/c]) any/c]
@defmethod[(render-paragraph [rendered-elems list?]) any/c]
@defmethod[(render-blockquote [rendered-elems list?]) any/c]
@defmethod[(render-itemization [style string?] [start string?] [rendered-items list?]) any/c]
@defmethod[(render-item [rendered-elems list?]) any/c]
@defmethod[(render-line-break) any/c]
@defmethod[(render-bold [rendered-elems list?]) any/c]
@defmethod[(render-italic [rendered-elems list?]) any/c]
@defmethod[(render-code [raw-elems list?]) any/c]
@defmethod[(render-link [dest string?] [title string?] [rendered-elems list?]) any/c]
@defmethod[(render-image [src string?] [title string?] [desc string?] [raw-elems list?]) any/c]
@defmethod[(render-html [raw-content any/c]) any/c]
@defmethod[(render-footnote-reference [label string?] [defn-num string?] [ref-num string?]) any/c]
@defmethod[(render-footnote-definition [label string?] [ref-count string?] [rendered-elems list?]) any/c]

}

